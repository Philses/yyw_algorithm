# 67. 优美的排列 II
### 原题
给定两个整数 n 和 k，你需要实现一个数组，这个数组包含从 1 到 n 的 n 个不同整数，同时满足以下条件：
① 如果这个数组是 [a1, a2, a3, ... , an] ，那么数组 [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] 中应该有且仅有 k 个不同整数；.
② 如果存在多种答案，你只需实现并返回其中任意一种.

示例 1:
输入: n = 3, k = 1
输出: [1, 2, 3]
解释: [1, 2, 3] 包含 3 个范围在 1-3 的不同整数， 并且 [1, 1] 中有且仅有 1 个不同整数 : 1

示例 2:
输入: n = 3, k = 2
输出: [1, 3, 2]
解释: [1, 3, 2] 包含 3 个范围在 1-3 的不同整数， 并且 [2, 1] 中有且仅有 2 个不同整数: 1 和 2


提示:
 n 和 k 满足条件 1 <= k < n <= 104.

来源：力扣（LeetCode）
[链接](https://leetcode-cn.com/problems/beautiful-arrangement-ii)：https://leetcode-cn.com/problems/beautiful-arrangement-ii

### 解法
```java
public int[] constructArray(int n, int k) {
        int[] result = new int[n];
        result[0] = n;
        for (int i = k + 1, temp = n - k - 1; i < n; i++, temp--)
            result[i] = temp;
        for (int i = 1, flag = -1, temp = k; i < k + 1; i++) {
            result[i] = result[i - 1] + temp * flag;
            flag = -1 * flag;
            temp--;
        }
        return result;
    }
```
思路分析：
* 这个题有多种可能的构造方式，我做的方法我也不知道我是以什么逻辑进行切入的。
* 首先，数组中相邻两个元素差的绝对值构成的集合，只能有k个元素。如果我让差刚好是`1,2,3,...k`，这是满足题意的。
* 使用的数字为`1,2,3...n`。
    * 如果我用数字`n`与`n-k`开头，那么就产生了差值`k`。
    * 我想要再产生相邻两个元素差的绝对值为`k-1`，在刚才选定第二个元素为`n-k`的基础上，我选择第三个数为`n - k + k - 1 = n - 1`即可。
    * 然后我还想产生相邻两个元素差的绝对值为`k - 2`，在第三个数位`n - 1`的基础上，我选择第四个元素为`n - 1 -（k - 2） = n - k  + 1`。
    * 一直持续到选择了数 `n - （k + 1）/ 2`。PS：这里的除是向下取整的。那么此时剩余还没有安排的数为 `1,2,3,...n - k - 1`。
    * 为了和选定的最后一个数`n - （k + 1）/ 2`差值尽量小，因为一开始我们设定差值的范围是`[1,k]`，只要这个差值小于小于等于`k`即可，剩下的元素降序排列，差值只会是1。所以选择`n - k - 1`排在`n - （k + 1）/ 2`后面，这两个数的差值为`（k + 1）/ 2`。k最小为1，满足设定：差值小于等于k。
* 然后举个例子来看看上述步骤
    * 比如n = 6，k = 3。按照上述步骤选出来的就是 6,3,5,4,2,1
    * 比如n = 8，k = 2。按照上述步骤选出来的就是 8,6,7,5,4,3,2,1
* 然后开始写代码：
    * 首先答案数组为`result = new int[n];`，设定第一个元素为`result[0] = n;`
    * 然后从第二个元素开始，交替进行当前元素等于上一个元素加上或者减去`temp`，`temp`不断从k减小到1。正负号交替就使用变量`flag`来表示符号，如此就可以将这个过程表示为一个循环，这些元素的索引从1到k。` for (int i = 1, flag = -1, temp = k; i < k + 1; i++)`，循环内部`temp`不断减小`temp--`，符号不断变更正负`flag = -1 * flag;`前元素等于上一个元素加上`temp * flag`
    * 然后将剩余元素`1,2,3,...n - k - 1`降序排列，从索引`k+1`开始
* 时间复杂度为$O(n)$，空间复杂度为$O(n)$。

运行结果：
* 执行用时 :1 ms, 在所有 Java 提交中击败了100.00%的用户
* 内存消耗 :44.8 MB, 在所有 Java 提交中击败了5.34%的用户

----
* 更多LeetCode题解请看[题解仓库](https://github.com/ustcyyw/yyw_algorithm)
* 题解框架由小工具自动生产，参考[工具项目](https://github.com/ustcyyw/markdown_tool)
* [我的github](https://github.com/ustcyyw)还有别的小项目也很好玩。卑微求个~小星星蟹蟹