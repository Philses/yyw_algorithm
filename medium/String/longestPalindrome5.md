# 5. 最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：
输入:` "babad"`
输出:` "bab"`
注意: `"aba"` 也是一个有效答案。

示例 2：
输入:` "cbbd"`
输出: `"bb"`

来源：力扣（LeetCode）
[链接](https://leetcode-cn.com/problems/longest-palindromic-substring)：https://leetcode-cn.com/problems/longest-palindromic-substring

### 两种方法

##### 1.中心扩展法

```java
public String longestPalindrome(String s) {
        int n = s.length();
        if (n < 2) return s;
        char[] chars = s.toCharArray();
        int start = 0, maxL = 1;
        for (int i = 0; i < n; i++) {
            for (int j = 1; i + j < n && i - j >= 0; j++) { // 以字符为中心
                if (chars[i - j] != chars[i + j]) break;
                else {
                    if (2 * j + 1 > maxL) {
                        maxL = 2 * j + 1;
                        start = i - j;
                    }
                }
            }
            for (int j = 0; i - j >= 0 && i + 1 + j < n; j++) { // 以两个字符的中间为中心
                if (chars[i - j] != chars[i + 1 + j]) break;
                else {
                    if(2 * j + 2 > maxL){
                        maxL = 2 * j + 2;
                        start = i - j;
                    }
                }
            }
        }
        return s.substring(start, start + maxL);
    }
```

思路分析：

* 先处理特殊情况，比如，给定的字符串是一个空串或者只有一个字符，从回文串的定义“反转之后相等”可知这两种特殊情况它们都是回文串，且显然也是最长子串。直接返回。
* 回文串的特征：对称。第一个字符与最后一个字符相等，第二个字符与倒数第二个字符相等...以此类推。类推的时候发现，如果字符串的长度为偶数，可以找到这样完整的一组组字符；如果字符串的长度为奇数，字符串中间的字符是没办法找到对应的字符的。所以，回文字符串的中心，可能是中间那个字符（长度为奇数时），也可能是中间两个字符间的空白（长度为偶数时）
* 回到问题，要找最长回文子串，并不能事先知道要找的回文子串长度是奇数还是偶数。所以回文子串的中心可能是各个字符或者每两个相邻的字符间的空白。如果原字符串的长度为`int n = s.length()`，那么可能的回文子字符串的中心有$2n+1$个。
* 为什么要考虑回文中心？从回文串的对称性来看，由外向中心和由中心向外都是可以判断一个字符串是否为回文的。但是涉及到子串时，如果知道`[i, j]`的子串是回文串就可以由`charAt[i - 1] == charAt[j + 1]`来判断`[i - 1, j + 1]`的子串是不是回文串。如果发现`[i, j]`的子串不是回文串，那么`[i - 1, j + 1]`的子串一定不是回文串，这样就可以节约很多重复计算。
* 接下来，回文中心如何表示。以及区间如何表示。参考下面的图示例，以`babad`为例子。列举了部分待判断的可能成为回文字串的子串。

![longestPalindrome5图示.png](https://github.com/ustcyyw/yyw_algorithm/blob/master/medium/String/longestPalindrome5%E5%9B%BE%E7%A4%BA.png?raw=true)

* 对于以字符为回文中心时。用`i`表示回文中心那个字符的索引。要表示出某个子串，可以用子串最左边（最右边）字符到中心字符的距离`j`表示，那么最左边字符的索引为`i - j`，最右边字符的索引为`i + j`。子串的长度为`2 * j + 1`。`j`从1开始递增即可，因为`j=0`时的子串是单个字符，不需要判断。
* 对于以两字符串中间空白为中心时。用`i`表示会问中心左边第一个字符的索引。要表示出某个子串，可以用子串最左边（最右边）字符到`i`这个字符的距离`j`表示，那么最左边字符的索引为`i - j`，最右边字符的索引为`i + j + 1`。子串的长度为`2 * j + 2`。`j`从0开始递增，因为`j=0`时的子串是两个字符组成，需要判断。
* 对于以上两种情况。
    * 都涉及到了索引，为了防止数组越界，都需要对子串最左边，最右边字符的索引进行规定。
    * 都涉及到从中心向外扩，当发现某个子字符已经不是回文串时，直接停止后续子串的判断
    * 当某个子串是回文串时要考虑是否是一个更长的回文串，如果是要进行更新。最终要找最长的回文字串，记录长度与起始索引就可以。
* 时间复杂度为$O(n^2)$，空间复杂度为$O(1)$
* 这里还需要注意，在进行初始条件的设定`int start = 0, maxL = 1;`，有可能通过中心扩展一直没有找到长度大于1的回文子串，此时就需要返回任意单个字符组成的子串。

代码解释：

* 第6行，`i`的循环，是对回文中心的遍历。
* 7-15行，以字符为中心的子串遍历; 16-24行，以两个字符的中间为中心的子串遍历
* 第8行，扩展的两端字符不相等，它不是回文串，该中心继续向外扩的字符串也不可能是回文串。
* 10-12行，必要时候进行更新最长子串的长度及起始点。

运行结果：
* 执行用时 :14 ms, 在所有 Java 提交中击败了79.97%的用户
* 内存消耗 :37.9 MB, 在所有 Java 提交中击败了25.93%的用户
##### 2.动态规划

```java
public String longestPalindrome2(String s) {
        int n = s.length();
        if (n < 2) return s;
        char[] chars = s.toCharArray();
        int start = 0, maxL = 1;
        boolean[][] p = new boolean[n][n]; // p[i][j] 表示子串[i,j]是否为一个回文串
        for(int i = 1; i < n; i++){ // i指定回文串的右边界
            p[i][i] = true;
            if(chars[i] == chars[i - 1]){
                p[i - 1][i] =true;
                if(maxL < 2){
                    maxL = 2;
                    start = i - 1;
                }
            }
            for(int j = i - 2; j >= 0; j--){ // j不断向左更新左边界。 本质上这两层循环 也是从中心往外扩地判断是不是回文串
                if(p[j + 1][i - 1] && chars[i] == chars[j]){
                    p[j][i] = true;
                    if(maxL < i - j + 1){
                        maxL = j - i + 1;
                        start = j;
                    }
                }
            }
        }
        return s.substring(start, start + maxL);
    }
```

思路分析：

* 有了方法一的铺垫，由中心向外扩展，也是一种自下而上解决问题的方式。可以想到，换成动态规划来解决这个问题。
* 首先定义状态。` p[i][j] `表示子串`[i,j]`是否为一个回文串。状态转移方程就是， `p[j][i]=p[j + 1][i - 1] && chars[i] == chars[j]`。这里存在的问题是`j + 1`与`i - 1`如何保证是`j + 1 <= i - 1`。要解决问题，需要想一下，什么情况下只用`chars[i] == chars[j]`这个条件就能判断`[j,i]`上的字符串是回文串
    * `i == j`，一定为回文串
    * `j + 1 == i`，此时子串只有两个字符。
* 第七行，对`i`从1到`n-1`进行遍历，`i`指定为子字符串的最右边字符的索引。那么先让` p[i][i] = true`，再通过`chars[i] == chars[i - 1]`来判断`p[i - 1][i]`。然后第16行的对`j`的遍历，用`j`表示子串最左边字符的索引。`j`就可以从`i - 2`开始，不断左移，这样就可以保证`j + 1 <= i - 1`一定成立了。
* 当某个子串是回文串时要考虑是否是一个更长的回文串，如果是要进行更新。最终要找最长的回文字串，记录长度与起始索引就可以。
* 特殊情况的处理同方法一。
* 时间复杂度为$O(n^2)$，空间复杂度为$O(n^2)$

代码解释：

运行结果：
* 执行用时 :76 ms, 在所有 Java 提交中击败了42.10%的用户
* 内存消耗 :42.8 MB, 在所有 Java 提交中击败了12.50%的用户

