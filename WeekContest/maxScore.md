# 5392. 分割字符串的最大得分
### 原题
给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。
「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。 

示例 1：
输入：s = "011101"
输出：5 
解释：
将字符串 s 划分为两个非空子字符串的可行方案有：
左子字符串 = "0" 且 右子字符串 = "11101"，得分 = 1 + 4 = 5 
左子字符串 = "01" 且 右子字符串 = "1101"，得分 = 1 + 3 = 4 
左子字符串 = "011" 且 右子字符串 = "101"，得分 = 1 + 2 = 3 
左子字符串 = "0111" 且 右子字符串 = "01"，得分 = 1 + 1 = 2 
左子字符串 = "01110" 且 右子字符串 = "1"，得分 = 2 + 1 = 3

示例 2：
输入：s = "00111"
输出：5
解释：当 左子字符串 = "00" 且 右子字符串 = "111" 时，我们得到最大得分 = 2 + 3 = 5

示例 3：
输入：s = "1111"
输出：3

提示：
2 <= s.length <= 500
字符串 s 仅由字符 '0' 和 '1' 组成。

来源：力扣（LeetCode）
[链接](https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string)：https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string

### 解法
```java
public int maxScore(String s) {
        int res = 0;
        char[] chars = s.toCharArray();
        int left = 0, right = 0;
        for (char c : chars) {
            if (c == '1')
                right++;
        }
        for (int i = 0; i < s.length() - 1; i++) {
            if (chars[i] == '0')
                left++;
            else right--;
            res = Math.max(res, left + right);
        }
        return res;
    }
```
思路分析：
* 要将字符串分成两部分非空的，左边部分计数0的个数，右边部分计数1的个数。所有可能的分组为：左边1个字符，右边n-1个字符；左边两个字符，右边n-2个字符……左边n-1个字符，右边1个字符。
* 只要遍历上述n-1种可能的分割方法，计算每种分割方法的分数，其中最大的就是答案。
* 为了避免每一种分割方式都遍历字符串，我们可以用`left, right`分别表示左边字符串中0的个数和右边字符串中1的个数。
    * 一开始先统计整个字符串中有多少个1，赋值给`right`，这个时候表示左字符串为空，右字符串为s的情况。
    * 以索引`i`为分割点，将字符串分为`[0, i]`和`[i + 1, s.length - 1]`两个部分。要求左右子串都不为空，所以`i`的取值范围是`0 <= i < s.length() - 1`。
    * 在`i`不断右移动的过程中，如果`chars[i] == '0'`，说明左边字符串0的个数+1。否则该字符为1且从右边被划分到左边了`right--`。每一次`i`移动都对应着一种分割方式，所以要求每种分割方法的分数，其中最大的，就在循环中`res = Math.max(res, left + right);`
* 最后返回`res`。
* 只对数组进行了两次遍历，所以时间复杂度是$O(n)$的，空间复杂度为$O(1)$。

运行结果：

* 1ms

----
* 更多LeetCode题解请看[题解仓库](https://github.com/ustcyyw/yyw_algorithm)
* 题解框架由小工具自动生产，参考[工具项目](https://github.com/ustcyyw/markdown_tool)
* [我的github](https://github.com/ustcyyw)还有别的小项目也很好玩。卑微求个~小星星蟹蟹