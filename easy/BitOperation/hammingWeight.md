# 191. 位1的个数

### 原题
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

示例 1：
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例 2：
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 3：
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

提示：
请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

进阶:
如果多次调用这个函数，你将如何优化你的算法？

来源：力扣（LeetCode）
[链接](https://leetcode-cn.com/problems/number-of-1-bits)：https://leetcode-cn.com/problems/number-of-1-bits

### 两种解法

##### 1.位运算

```java
public int hammingWeight(int n) {
        int count = 0;
        while(n != 0){
            if((n & 1) == 1)
                count++;
            n >>>= 1; //
        }
        return count;
    }
```

思路分析：

* 要统计二进制表达式中数字位数为 ‘1’ 的个数，需要知道该数的二进制表示。这题中的做法是一个非常标准的方式。
* 任何一个数`n`和1做与运算`n & 1`，得到的都是n的二进制表示的第一位的数字。得到第一位之后如何得到第二位，可以对`n`进行右移1位，这样`n`原来的第一位就被舍去，第二位被移动到第一位。
* 但是这里要注意，在java中右移`>>`进行有符号右移动，对于负数其高位会一直添加1，移位统计就永远不会结束。所以我们使用无符号右移`>>>`，无论正数还是负数都在高位补0。
* 每次将n无符号右移一位，直到`n==0`，此时已经将所有的1统计完成了。
* 时间复杂度：$O(1)$ 。运行时间依赖于数字 n的位数。由于这题中 n 是一个 32 位数。空间复杂度是$O(1)$的。


运行结果：
* 执行用时 :1 ms, 在所有 Java 提交中击败了99.75%的用户
* 内存消耗 :36.3 MB, 在所有 Java 提交中击败了5.45%的用户

##### 2.官方解法

```java
public int hammingWeight2(int n) {
        int count = 0;
        while(n != 0){
            count++;
            n = n & (n - 1);
        }
        return count;
    }
```

思路分析：

* 这里运用一个常用技巧，任何数 x在进行了 x & (x - 1)后都将其二进制表示的最低一位1变成了。
* 那么要统计一个数的二进制表示中有多少个1，就去计算进行多少次 n & (n - 1)后（别忘了赋值），n变为0即可。
* 时间复杂度：$O(1)$ 。运行时间依赖于数字 n中1的位数，至多进行32次操作。空间复杂度是$O(1)$的。