# 476. 数字的补数

### 原题
给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

示例 1:
输入: 5
输出: 2
解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。

示例 2:
输入: 1
输出: 0
解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。

注意:

给定的整数保证在 32 位带符号整数的范围内。
你可以假定二进制数不包含前导零位。
本题与 1009 https://leetcode-cn.com/problems/complement-of-base-10-integer/ 相同

来源：力扣（LeetCode）
[链接](https://leetcode-cn.com/problems/number-complement)：https://leetcode-cn.com/problems/number-complement

### 解法： 位运算

```java
public int findComplement(int num) {
        int move = 0;
        int res = 0;
        while(num != 0){
            int temp = num & 1;
            if(temp == 0) res += (1 << move);
            move++;
            num >>>= 1;
        }
        return res;
    }
```

思路分析：

* 要对该数的二进制表示取反，首先需要知道每一位二进制位的数字是多少。这个做法就是常规的，用`int temp = num & 1;`得到当前位的数字。不断移位的操作也是常规的while循环和无符号右移`num >>>= 1`。

* 但是怎么将数字取反后放到合适的位置。可以看一个例子。以 110010为例子

    * ```
        第一位是0，该位取反为1   000001
        第二位是1，该位取反为0   000000
        第三位是0，该位取反为1   000100
        第四位是0，该位取反为1   001000
        第五位是1，该位取反为0   000000
        第六位是1，该位取反为0   000000
        相加                  001101 即为110010的按位取反
        ```

    * 所以我们发现，当第`i`位数字为0时，就应该将1左移`i-1`位，成为最后结果的加数之一。当然第`i`位数字为1时，取反为0，就没必要进行移位相加了（反正都是0不影响）

    * 所以我们用一个变量`move`来表示需要左移多少位。

* 注意到题目说每个数都没有前导零位，所以循环结束的标志就是`num == 0`。

* 时间复杂度为$O(n)$，空间复杂度为$O(1)$。

运行结果：
* 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户
* 内存消耗 :36.3 MB, 在所有 Java 提交中击败了5.33%的用户