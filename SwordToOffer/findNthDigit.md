# 面试题44. 数字序列中某一位的数字
### 原题
数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
请写一个函数，求任意第n位对应的数字。 

示例 1：
输入：n = 3
输出：3

示例 2：
输入：n = 11
输出：0

限制：
0 <= n < 2^31
注意：本题与主站 400 题相同：https://leetcode-cn.com/problems/nth-digit/

来源：力扣（LeetCode）
[链接](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof)：https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof

### 解法
```java
public class findNthDigit {
    // 0, 一位数，两位数，三位数……的累计数字的和
    private static int[] sum = {10, 190, 2890, 38890, 488890, 5888890, 68888890, 788888890};
    public int findNthDigit(int n) {
        if (n <= 9) return n;
        int i = 0;
        for (; i < sum.length && n >= sum[i]; i++) ;
        int left = n - sum[i - 1];
        int index = left / (i + 1), offset = left % (i + 1);
        String num = String.valueOf((int) Math.pow(10, i) + index);
        return num.charAt(offset) - '0';
    }
}
```
思路分析：
* 数每次加1并且按照字符串拼接的规则进行排列，求索引为n的数字是[0-9]中的哪一个。
* 每一个数能给字符串贡献多少长度就很重要：因为要去找指定索引的数（索引与序列长度一一对应）
    * 0-9这样的一位数可以贡献长度1，这些数一共可以贡献10个长度；
    * 10-99这样的两位数可以贡献长度2，这些数一共可以贡献2 * 90 = 180个长度；
    * 100-999这样的三位数可以贡献长度3，这些数一共可以贡献3 * 900 = 2700个长度；
    * 以此类推八位数可以贡献长度8，这些数一共可以贡献90000000 * 8 = 720000000个长度
* 确定了这些组别一共可以使数字序列增加的长度，如果给我们一个n，比如2891。
    * 从上面枚举的结果来看，一位数，两位数，三位数贡献的长度为10 + 180 + 2700 = 2890，那么索引2891的数字，对应的序列长度为2892（长度等于索引+1），就应该是四位数中的某一位数字。
    * 四位数从1000开始，要再贡献长度2，那么就是第一个四位数1000的第二个数字0，这就是答案。
* 再举一个例子，给定n = 198。
    * 一位数与两位数贡献了190的长度，并且198小于2890，所以结果应该是三位数中的某一位数字。
    * 三位数从100开始，要再贡献长度199 - 190 = 9，应该是第3个三位数，102的第3个数字2。
* 然后开始归纳规律：
    * 首先上述计算过程，我们需要知道前缀和，这用于判断制定的索引的数字来自于几位数。前缀和数组枚举为`static int[] sum`。
    * 特别地，对于索引0-9，直接返回`n`即可。
    * 利用前缀和数组，我们要找到`i`使得`sum[i] > n >= sum[i - 1]`，使用循环`for (; i < sum.length && n >= sum[i]; i++) ;`。于是就确定了答案应该在i + 1位数中。（比如刚才举的两个例子中，i分别为3和2，所以结果是在四位数，三位数中找到的）。
    * 知道答案是i+1位数中产生的，意义就在于，使用`int left = n - sum[i - 1]`得到还需要的长度-1，于是通过这个就能知道是第几个i+1位数产生的。使用`int index = left / (i + 1)`得到的`index`的意义是`index + 1`即为第几个i+1位数，注意1000……是第一个i+1位数，所以1000……+index刚好就是产生答案的那个数（好绕口啊，举例子自己推一下啊。比如index=0，那么就应该是第1个i+1位数，那刚好就是1000……+0）。
    * 然后还要确定是这个数中的第几个数字，刚好`offset = left % (i + 1);`，这样计算又刚好能得到索引了。这里借助字符串来完成查找，先转为为字符串`String num = String.valueOf((int) Math.pow(10, i) + index);`（注意这里一定要强制类型转换为int，否则会出现科学计数的字符串形式，就错了），然后`num.charAt(offset)`就是答案对应的字符，再减去字符`'0'`就得到答案。
* 时间复杂度：前缀和数组的循环中，最多8次，剩下的计算也是常数次，所以是$O(1)$的。空间复杂度也仅用了一个长度为8的数组与几个辅助变量，也是$O(1)$的。

运行结果：

* 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户
* 内存消耗 :35.8 MB, 在所有 Java 提交中击败了100.00%的用户

----
* 更多LeetCode题解请看[题解仓库](https://github.com/ustcyyw/yyw_algorithm)
* 题解框架由小工具自动生产，参考[工具项目](https://github.com/ustcyyw/markdown_tool)
* [我的github](https://github.com/ustcyyw)还有别的小项目也很好玩。卑微求个~小星星蟹蟹